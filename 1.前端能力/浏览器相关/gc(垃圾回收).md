# 垃圾回收

*垃圾回收也叫gc，有些面试官喜欢说gc，要反应过来*

> V8的内存限制(为什么说起V8我的脑海中就会出现发动机的画面)

一般64位系统里可以使用的内存位1.4G,32位的就只有0.7G了

> 内存限制的原因

1.v8是为了浏览器设计，这个限制已经足够浏览器使用
2。以1.5G内存的垃圾回收堆内存为例，v8执行一次小的垃圾回收就需要50毫秒之上，执行一次增量垃圾回收更是需要1s以上，更由于*垃圾回收会阻塞js线程*,所以v8限制了内存

> v8的对象分配

基本类型都存储在栈中，所有的对象都分配给了堆处理，我们每赋值一个对象，该对象的内存就会分配在堆当中，如果已申请的内存不够，则再继续申请新的堆内存。

> v8的内存分代

申请下的堆内存又分为新生代，老生代.新生代就是存活时间较短的对象，老生代则是存活时间较长或者常驻的对象。

> scanvenge算法

这是运用于新生代的算法，将新生代分为from和to两块空间，每次垃圾回收的时候将from空间里存活的对象复制到to空间里，下次运行的时候to空间就再次变成了from空间。这种算法的特点是将内存分为两块，但是速度快，典型的牺牲空间换时间

> scanvenge算法主要用于新生代，那么什么时候对象会转移到



> sweet mark & sweet compare

中文叫做标记清除法，每次回收垃圾的时候，都会先遍历标记存活的对象，清除掉未标记的对象。这样就会存在空间不连续的情况。所以有一种新的回收方法，叫标记，准备，清除，这种方法在标记后，会把标记的对象移动到一遍，清除未标记的对象，这样就解决了存储空间不连续的问题。

